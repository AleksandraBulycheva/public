"""
Задание состоит из двух частей.
1 часть – написать программу в соответствии со своим вариантом задания.
Написать 2 варианта формирования (алгоритмический и с помощью функций Питона), сравнив по времени их выполнение.
2 часть – усложнить написанную программу,
введя по своему усмотрению в условие минимум одно ограничение на характеристики объектов (которое будет сокращать количество переборов)
и целевую функцию для нахождения оптимального  решения.

Вариант 4. IT-предприятие набирает сотрудников: 2 тимлида, 2 проджек-менеджера, 3 синьера, 3 мидла, 4 юниора.
Сформировать все возможные варианты заполнения вакантных мест, если имеются 16 претендентов.
"""
import itertools
import time

# Вакансии
vacancies_requirements = {
    "тимлид": 2,
    "проджект-менеджер": 2,
    "синьер": 3,
    "мидл": 3,
    "юниор": 4
}

# Количество претендентов
count_of_candidates = 16

# Все комбинации по размеру вакансий
total_needed = sum(vacancies_requirements.values())

# Максимальная сумма зарплат
salary_cap = 84000

# Зарплаты претендентов
salaries = [4300, 5600, 2700, 3400, 9100, 3700, 2500, 6500, 8400, 5200, 7300, 6800, 8100, 9200, 8900, 6100]


# Оценка стоимости работников
def group_cost(group):
    return sum(salaries[i] for t in group for i in t)


# Генерация комбинаций без itertools.combinations
def combinations(array, k, start=0, current_combination=[]):
    if len(current_combination) == k:
        yield tuple(current_combination)
    else:
        for i in range(start, len(array)):
            yield from combinations(array, k, i + 1, current_combination + [array[i]])


# Функция для разделения списка на группы указанного размера
def partition(arr, sizes):
    results = []
    start = 0
    for size in sizes:
        end = start + size
        results.append(arr[start:end])
        start = end
    return results


# Алгоритмический подход с учетом ограничения по зарплате
def algorithmic_groups_generation_with_salary_cap(count_of_candidates, total_needed, salary_cap):
    groups = []
    for candidates_comb in combinations(range(count_of_candidates), total_needed):
        if group_cost(partition(candidates_comb, vacancies_requirements.values())) <= salary_cap:
            groups.append(partition(candidates_comb, vacancies_requirements.values()))
    return groups

# Подход с itertools с учетом ограничения по зарплате
def itertools_groups_generation_with_salary_cap(count_of_candidates, total_needed, salary_cap):
    candidates_comb = list(itertools.combinations(range(count_of_candidates), total_needed))
    return [partition(comb, vacancies_requirements.values()) for comb in candidates_comb if group_cost(partition(comb, vacancies_requirements.values())) <= salary_cap]

# Замер времени работы алгоритмического подхода с учетом ограничения по зарплате
start_time = time.time()
algorithmic_groups_with_salary_cap = algorithmic_groups_generation_with_salary_cap(count_of_candidates, total_needed, salary_cap)
end_time = time.time()
print(f"Алгоритмический подход с учетом ограничения по зарплате: {end_time - start_time} секунд, {len(algorithmic_groups_with_salary_cap)} комбинаций")

# Замер времени работы подхода с itertools с учетом ограничения по зарплате
start_time = time.time()
itertools_groups_with_salary_cap = itertools_groups_generation_with_salary_cap(count_of_candidates, total_needed, salary_cap)
end_time = time.time()
print(f"Подход с itertools с учетом ограничения по зарплате: {end_time - start_time} секунд, {len(itertools_groups_with_salary_cap)} комбинаций")

# Вывод всех комбинаций алгоритмического подхода с учетом ограничения по зарплате
print("Алгоритмический подход с учетом ограничения по зарплате:")
for group in algorithmic_groups_with_salary_cap:
    print(group, group_cost(group))

# Вывод всех комбинаций подхода с itertools с учетом ограничения по зарплате
print("\nПодход с itertools с учетом ограничения по зарплате:")
for group in itertools_groups_with_salary_cap:
    print(group, group_cost(group))

